
# agent.py

# good to have
import os

# ALWAYS used
import json
from pathlib import Path
from dotenv import load_dotenv
from any_agent import AgentConfig, AnyAgent, AgentRunError
from pydantic import BaseModel, Field
from fire import Fire

# ADD BELOW HERE: tools made available by any-agent or agent-factory
from typing import List
from any_agent.config import MCPStdio

from tools.extract_text_from_url import extract_text_from_url
from tools.generate_podcast_script_with_llm import generate_podcast_script_with_llm
from tools.combine_mp3_files_for_podcast import combine_mp3_files_for_podcast

load_dotenv()

# ========== Structured output definition ==========
class TurnAudioPaths(BaseModel):
    speaker: str = Field(..., description="Name of the speaker for this audio turn.")
    file_path: str = Field(..., description="Path to the mp3 file for this turn.")

class StructuredOutput(BaseModel):
    final_mp3_path: str = Field(..., description="Path to the combined podcast mp3 file.")
    script_text: str = Field(..., description="Full podcast script generated by the agent.")
    turn_mp3s: List[TurnAudioPaths] = Field(..., description="Ordered list of per-turn mp3 files and their speakers.")

# ========== System (Multi-step) Instructions ===========
INSTRUCTIONS='''
You are PodCraft, an expert podcast-creation assistant. Work through these explicit steps and do not skip any:

STEP 1 – Extract source text
• Use `extract_text_from_url(url)` on the URL provided in the prompt.
• Return only the main readable content (no nav, ads, or boiler-plate).

STEP 2 – Draft podcast script (≤ 16 dialogue turns)
• Use `generate_podcast_script_with_llm(text, host_name, guest_name, max_turns=16)`.
• Write a lively back-and-forth between the host and guest summarising & expanding on the page’s key ideas.
• Keep each turn under 90 words and label each line clearly with the speaker’s name, e.g. “Alex: …”.

STEP 3 – Produce per-turn audio
For each dialogue turn in order:
• Identify the speaker.
• Choose the corresponding ElevenLabs voice (host_voice for host, guest_voice for guest).
• Call `text_to_speech(text=<turn_text>, voice_name=<chosen_voice>, directory="/tmp", format="mp3")`.
• Save files as `/tmp/turn_<index>_<speaker>.mp3` and record the paths.

STEP 4 – Combine into single podcast file
• After all turn files are created, call `combine_mp3_files_for_podcast(mp3_file_paths=<ordered_list>, output_file="/tmp/podcast.mp3")`.

STEP 5 – Return structured output
Respond with JSON that matches the StructuredOutput schema:
  – final_mp3_path: "/tmp/podcast.mp3"
  – script_text: full script with speaker labels
  – turn_mp3s: ordered list of {speaker, file_path} objects

General rules
• Always save ALL audio in /tmp.
• Never exceed 16 dialogue turns.
• Fail gracefully: if a step errors, stop and describe the failure in the JSON fields.
'''

# ========== Tools definition ===========
TOOLS = [
    extract_text_from_url,                 # STEP 1
    generate_podcast_script_with_llm,      # STEP 2
    combine_mp3_files_for_podcast,         # STEP 4
    MCPStdio(
        command="uvx",                    # Use uvx installation
        args=["elevenlabs-mcp"],
        env={
            "ELEVENLABS_API_KEY": os.getenv("ELEVENLABS_API_KEY"),
        },
        tools=[
            "text_to_speech",             # STEP 3 – core TTS tool
        ],
    ),
]

# ========== Running the agent via CLI ===========
agent = AnyAgent.create(
    "openai",
    AgentConfig(
        model_id="o3",
        instructions=INSTRUCTIONS,
        tools=TOOLS,
        output_type=StructuredOutput,  # name of the Pydantic v2 model defined above
        model_args={"tool_choice": "auto"},
    ),
)


def main(url: str, host_name: str = "Alex", guest_name: str = "Jordan", host_voice: str = "Rachel", guest_voice: str = "Domi"):
    """Generate a short (<16 turns) dialogue-style podcast from a webpage, synthesize each turn to speech with ElevenLabs, combine into one MP3 saved in /tmp, and return structured details."""
    input_prompt = f"Create a podcast from the webpage below.\nURL: {url}\nHost Name: {host_name}\nGuest Name: {guest_name}\nHost Voice: {host_voice}\nGuest Voice: {guest_voice}"
    try:
        agent_trace = agent.run(prompt=input_prompt, max_turns=20)
    except AgentRunError as e:
        agent_trace = e.trace
        print(f"Agent execution failed: {str(e)}")
        print("Retrieved partial agent trace...")

    # Extract cost information (with error handling)
    try:
        cost_info = agent_trace.cost
        if cost_info.total_cost > 0:
            cost_msg = (
                f"input_cost=${cost_info.input_cost:.6f} + "
                f"output_cost=${cost_info.output_cost:.6f} = "
                f"${cost_info.total_cost:.6f}"
            )
            print(cost_msg)
    except Exception:
        class DefaultCost:
            input_cost = 0.0
            output_cost = 0.0
            total_cost = 0.0
        cost_info = DefaultCost()

    # Create enriched trace data with costs as separate metadata
    script_dir = Path(__file__).resolve().parent
    output_path = script_dir / "agent_eval_trace.json"

    # Prepare the trace data with costs
    trace_data = agent_trace.model_dump()
    trace_data["execution_costs"] = {
        "input_cost": cost_info.input_cost,
        "output_cost": cost_info.output_cost,
        "total_cost": cost_info.total_cost
    }

    with open(output_path, "w", encoding="utf-8") as f:
        f.write(json.dumps(trace_data, indent=2))

    return agent_trace.final_output


if __name__ == "__main__":
    Fire(main)
