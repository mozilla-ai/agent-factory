import json
from pathlib import Path
from typing import Any
from uuid import uuid4

import chainlit as cl
import chainlit.cli
import httpx
from a2a.client import A2ACardResolver, A2AClient
from a2a.types import (
    AgentCard,
    MessageSendParams,
    SendMessageRequest,
)
from pydantic import BaseModel, Field
from templates import AGENT_CODE_TEMPLATE

PUBLIC_AGENT_CARD_PATH = "/.well-known/agent.json"
EXTENDED_AGENT_CARD_PATH = "/agent/authenticatedExtendedCard"


class AgentFactoryOutputs(BaseModel):
    answer: str = Field(..., description="The answer to the user's question, generated by the agent.")
    code_ready: bool = Field(..., description="Whether the agent has completed the user assigned task.")
    agent_instructions: str = Field(..., description="The instructions passed to the generated agent.")
    tools: str = Field(..., description="The python code that defines the tools to be used by the generated agent.")
    imports: str = Field(..., description="The python code snippet used to import the required tools.")
    structured_outputs: str = Field(..., description="The Pydantic v2 models used to structure the agent's output.")
    agent_description: str = Field(..., description="The description of the agent and what it does.")
    readme: str = Field(..., description="The run instructions in Markdown format")
    dependencies: str = Field(..., description="The dependencies line by line in Markdown format")


def save_agent_locally(result: dict[str, str], agent_id: str) -> None:
    """Saves the agent's code and instructions locally."""
    Path(f"generated_agents/{agent_id}").mkdir(parents=True, exist_ok=True)

    agent_code = AGENT_CODE_TEMPLATE.format(**result)
    with Path(f"generated_agents/{agent_id}/agent.py").open("w") as f:
        f.write(agent_code)

    with Path(f"generated_agents/{agent_id}/README.md").open("w") as f:
        f.write(result["readme"])

    with Path(f"generated_agents/{agent_id}/requirements.txt").open("w") as f:
        f.write(result["dependencies"])


@cl.on_chat_start
async def on_chat_start():
    """Initialize the chat session"""
    cl.user_session.set("message_history", [])

    # Settings for the agent server connection
    host = "localhost"
    port = 8080
    timeout = 600
    base_url = f"http://{host}:{port}"

    try:
        httpx_client = httpx.AsyncClient(timeout=1500)
        resolver = A2ACardResolver(
            httpx_client=httpx_client,
            base_url=base_url,
        )

        agent_card: AgentCard = await resolver.get_agent_card()
        client = A2AClient(httpx_client=httpx_client, agent_card=agent_card)

        cl.user_session.set("a2a_client", client)
        cl.user_session.set("context_id", str(uuid4()))
        cl.user_session.set("timeout", timeout)

        await cl.Message(
            content=f"Connection to agent at {base_url} established. Ready to chat!",
            author="assistant",
        ).send()

    except Exception as e:
        await cl.Message(
            content=f"Failed to connect to agent server: {e}",
            author="Error",
        ).send()


@cl.on_message
async def on_message(message: cl.Message):
    """Handle incoming messages"""
    client = cl.user_session.get("a2a_client")
    context_id = cl.user_session.get("context_id")
    timeout = cl.user_session.get("timeout")

    if not client:
        await cl.Message(
            content="A2A client not initialized. Please restart the chat.",
            author="Error",
        ).send()
        return

    send_message_payload: dict[str, Any] = {
        "message": {
            "role": "user",
            "parts": [{"kind": "text", "text": message.content}],
            "messageId": str(uuid4()),
            "contextId": context_id,
        },
    }
    request = SendMessageRequest(id=str(uuid4()), params=MessageSendParams(**send_message_payload))

    try:
        result = await client.send_message(request, http_kwargs={"timeout": timeout})
        response_data = json.loads(result.root.result.status.message.parts[0].root.text)
        response = AgentFactoryOutputs(**response_data)

        if response.code_ready:
            save_agent_locally(response.dict(), context_id)

        await cl.Message(
            content=response.answer,
            author="assistant",
        ).send()

    except Exception as e:
        await cl.Message(
            content=f"An error occurred: {e}",
            author="Error",
        ).send()


if __name__ == "__main__":
    chainlit.cli.run_chainlit(__file__)
